/**
 * 给定正整数 n，返回若干个完全平方数之和等于 n 时所需的最少完全平方数的个数。
 * 例如：n = 12 -> 4 （因为 12 = 4 + 4 + 4）
 *
 * 这里用的是「动态规划（完全背包/最短组合）」的预计算方法：
 * - 先把 f[x] 定义为：组成 x 需要的最少完全平方数个数
 * - 初始 f[0] = 0，其他 f[x] 设为无穷（表示还未计算到或无法达到）
 * - 枚举每个完全平方数 i*i，然后像「完全背包」一样用它去更新所有目标值 j
 */

/* 预设一个上界 N，提前把 0..N 的答案都算出来（加速多次查询） */
const N = 10000;

/* f[j] 表示组成整数 j 所需的最少完全平方数个数，初始都设为 Infinity（不可达/未计算） */
const f = Array(N + 1).fill(Infinity);

/* 组成 0 需要 0 个完全平方数（空集）*/
f[0] = 0;

/* 
 * 外层循环：枚举完全平方数 i*i （i 从 1 开始）
 * 只需要枚举到 i*i <= N（即 i <= sqrt(N)）
 */
for (let i = 1; i * i <= N; i++) {
  /* 内层循环：对于每个能被当前完全平方数影响的目标值 j，
   * 尝试用一个 i*i 来“拼”出 j，看是否能减少所需个数。
   * 这里是「完全背包」/「完全可重复使用物品」的写法，
   * 因为同一个完全平方数可以被重复使用（例如 4 可以用多个 4 相加）。
   *
   * j 从 i*i 开始，因为比 i*i 更小的 j 无法用 i*i 来更新（会访问负索引）。
   */
  for (let j = i * i; j <= N; j++) {
    // 尝试用一个 i*i 再加上组成 j - i*i 所需的最少个数，看看是否更小
    f[j] = Math.min(f[j], f[j - i * i] + 1);
  }
}

/**
 * 外部调用函数：返回 n 的最少完全平方数个数（依赖上面预计算的 f）
 * 注意：本实现假设 n <= N（即 n 最大为 10000），否则需要扩展或按需计算
 */
var numSquares = function (n) {
  return f[n];
};
