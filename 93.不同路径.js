/**
 * 题目：给定一个 m 行 n 列的网格，机器人从左上角 (0,0) 出发，
 * 每次只能向 **右** 或 **下** 走一步，问有多少种不同的路径可以走到右下角 (m-1, n-1)。
 * 
 * @param {number} m - 网格的行数
 * @param {number} n - 网格的列数
 * @return {number} - 到达右下角的路径总数
 */
var uniquePaths = function (m, n) {
  // 1. 创建一个二维数组 f[m][n] 用来存储每个位置的路径数
  //    f[i][j] 表示从起点 (0,0) 到达位置 (i,j) 的不同路径总数
  //    先将所有位置初始化为 0
  const f = new Array(m).fill(0).map(() => new Array(n).fill(0));

  // 2. 初始化第一列
  //    机器人在第一列的每个位置 (i, 0) 只能从上面一直往下走
  //    因此到达第一列任意位置的路径数都只有 1
  for (let i = 0; i < m; i++) {
    f[i][0] = 1;
  }

  // 3. 初始化第一行
  //    机器人在第一行的每个位置 (0, j) 只能从左边一直往右走
  //    因此到达第一行任意位置的路径数也只有 1
  for (let j = 0; j < n; j++) {
    f[0][j] = 1;
  }

  // 4. 填充剩余的 DP 表
  //    从 (1,1) 开始计算，因为第一行和第一列已经初始化好了
  for (let i = 1; i < m; i++) {          // 从第二行开始
    for (let j = 1; j < n; j++) {        // 从第二列开始
      /**
       * 到达当前格子 (i, j) 的路径有两种可能：
       * 1. 从上面 (i-1, j) 向下走一步
       * 2. 从左边 (i, j-1) 向右走一步
       * 所以到达 (i, j) 的总路径数 = 上面格子的路径数 + 左边格子的路径数
       */
      f[i][j] = f[i - 1][j] + f[i][j - 1];
    }
  }

  // 5. 返回右下角位置 (m-1, n-1) 的路径总数
  return f[m - 1][n - 1];
};
