/**
 * åˆ¤æ–­ s[left..right] æ˜¯å¦æ˜¯å›æ–‡ä¸²
 * @param {string} s - åŸå§‹å­—ç¬¦ä¸²
 * @param {number} left - èµ·å§‹ä½ç½®
 * @param {number} right - ç»“æŸä½ç½®
 * @return {boolean} - æ˜¯å¦æ˜¯å›æ–‡
 */
var isPalindrome = function(s, left, right) {
    while (left < right) {
        // å·¦å³æŒ‡é’ˆå‘ä¸­é—´æ”¶ç¼©
        if (s.charAt(left++) !== s.charAt(right--)) {
            return false; // ä¸€æ—¦æœ‰ä¸ç›¸ç­‰çš„å­—ç¬¦ï¼Œå°±ä¸æ˜¯å›æ–‡
        }
    }
    return true; // å…¨éƒ¨ç›¸ç­‰å°±æ˜¯å›æ–‡
}

/**
 * @param {string} s - å¾…åˆ†å‰²çš„å­—ç¬¦ä¸²
 * @return {string[][]} - æ‰€æœ‰åˆæ³•çš„å›æ–‡åˆ†å‰²ç»„åˆ
 */
var partition = function(s) {
    const n = s.length;
    const ans = [];    // å­˜å‚¨æœ€ç»ˆç»“æœ
    const path = [];   // å­˜å‚¨å½“å‰åˆ†å‰²è·¯å¾„ï¼ˆæ¯æ®µå›æ–‡å­ä¸²ï¼‰

    /**
     * dfs(i, start) è¡¨ç¤ºï¼š
     *   i ğŸ‘‰ å½“å‰å¤„ç†åˆ°çš„ä½ç½®ï¼ˆs[i] æ˜¯å½“å‰è€ƒè™‘çš„å­—ç¬¦ï¼‰
     *   start ğŸ‘‰ å½“å‰å›æ–‡å­ä¸²çš„å¼€å§‹ä½ç½®
     * æˆ‘ä»¬åœ¨ i å’Œ i+1 ä¹‹é—´è¦ä¹ˆã€Œåˆ†å‰²ã€ã€è¦ä¹ˆã€Œä¸åˆ†å‰²ã€
     */
    function dfs(i, start) {
        // âœ… å½“ i åˆ°è¾¾å­—ç¬¦ä¸²æœ«å°¾ï¼Œè¯´æ˜ä¸€æ¡å®Œæ•´çš„åˆ†å‰²è·¯å¾„å®Œæˆ
        if (i === n) {
            ans.push(path.slice()); // å¤åˆ¶å½“å‰è·¯å¾„ï¼Œå­˜å…¥ç»“æœ
            return;
        }

        // ğŸš« æƒ…å†µ 1ï¼šã€Œä¸åˆ†å‰²ã€
        // è¡¨ç¤º i å’Œ i+1 ä¹‹é—´ä¸æ’é€—å·ï¼Œç»§ç»­å¾€åèµ°
        if (i < n - 1) {  // i = n-1 æ—¶ä¸èƒ½å†ä¸åˆ†å‰²äº†
            dfs(i + 1, start);
        }

        // âœ… æƒ…å†µ 2ï¼šã€Œåˆ†å‰²ã€
        // é€‰ i å’Œ i+1 ä¹‹é—´çš„é€—å·ï¼Œå½“å‰å­ä¸²ç»“æŸ
        // åˆ¤æ–­ s[start..i] æ˜¯å¦æ˜¯å›æ–‡ä¸²
        if (isPalindrome(s, start, i)) {
            // å¦‚æœæ˜¯å›æ–‡ï¼Œå°±æŠŠå®ƒåŠ å…¥å½“å‰è·¯å¾„
            path.push(s.substring(start, i + 1));
            // é€’å½’ä¸‹ä¸€æ®µä» i+1 å¼€å§‹
            dfs(i + 1, i + 1);
            // å›æº¯ï¼šç§»é™¤åˆšåŠ å…¥çš„å­ä¸²ï¼Œå°è¯•å…¶ä»–åˆ†å‰²æ–¹å¼
            path.pop();
        }
    }

    // ä»ç¬¬ 0 ä¸ªå­—ç¬¦å¼€å§‹æœç´¢
    dfs(0, 0);
    return ans;
}
