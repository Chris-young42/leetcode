/**
 * @param {string} s
 * @return {number} - 返回最长有效括号子串的长度
 *
 * 思路：
 * 1. 用动态规划（Dynamic Programming, DP）求解。
 * 2. 定义 dp[i] 表示：**以 s[i] 这个字符结尾的最长有效括号子串长度**。
 *    - 注意是“以 i 结尾”，所以 dp[i] 只考虑 [0..i] 范围内的子串。
 * 3. 最后，答案就是 dp 数组中的最大值。
 */
var longestValidParentheses = function (s) {
  let maxLen = 0; // 记录最长有效括号的全局最大值
  const n = s.length;
  const dp = new Array(n).fill(0); // 初始化 dp 数组为 0

  /**
   * 遍历字符串
   * - 从 i = 1 开始，因为 i = 0 时，不可能构成有效括号对
   */
  for (let i = 1; i < n; i++) {
    // 只有遇到右括号 ')'，才可能形成有效括号子串
    if (s[i] === ")") {
      /**
       * 情况 1：当前字符和前一个字符组成 "()" 这种直接匹配的情况
       * 比如："...()"
       *
       * 举例：
       * s = "(()"
       * i = 2（当前字符 s[i] = ')'）
       * s[i-1] = '(' → 成立
       *
       * 计算：
       * dp[i] = dp[i-2] + 2
       * - dp[i-2] 表示 "()" 前面可能还有有效括号长度
       * - 如果 i-2 < 0，说明没有前面的部分，则默认为 0
       */
      if (s[i - 1] === "(") {
        dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
      } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] === "(") {
        /**
         * 情况 2：当前字符是 ')'，并且前一个字符也是 ')'，
         * 需要判断更复杂的情况："...))"
         *
         * 思路：
         *   - 先看前一个位置的 dp[i-1]，它表示以 i-1 结尾的有效长度。
         *   - 如果 s[i - dp[i-1] - 1] 是 '('，说明这个 '(' 和当前的 ')' 可以匹配，
         *     然后再加上 dp[i-1]，以及这个匹配对之前的有效长度。
         *
         * 例如：
         * s = "()(())"
         * i = 5（当前字符 s[i] = ')'）
         * dp[i-1] = 4，表示 [2..4] 是 "(())"
         * i - dp[i-1] - 1 = 5 - 4 - 1 = 0
         * s[0] = '(' → 成立
         *
         * 公式：
         * dp[i] = dp[i-1] + 2 + dp[i - dp[i-1] - 2]
         * - dp[i-1]：是中间那一段 "(())" 的长度
         * - +2：是当前匹配的一对 "()" 的长度
         * - dp[i - dp[i-1] - 2]：是这对 "()" 之前的有效长度
         */
        dp[i] =
          dp[i - 1] + // 中间有效括号的长度
          2 + // 当前匹配的这对 "()"
          (i - dp[i - 1] >= 2 ? dp[i - dp[i - 1] - 2] : 0); // 这对括号之前的有效长度
      }

      // 更新全局最大长度
      maxLen = Math.max(maxLen, dp[i]);
    }
    // 如果 s[i] 是 '('，dp[i] 保持为 0，继续下一轮
  }

  return maxLen;
};
